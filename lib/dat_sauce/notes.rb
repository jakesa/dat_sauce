# get list of tests
# get tests options
# get number of available nodes
# it might be worth while to look into pulling down the repo to the machine that this is run on.  Im thinking we would host a Jekins server on AWS so that
# we can spawn 1000+ processes for sending to Sauce should we get the ability to fire up a VM for every test we can run
# our current limitation without taking into account SauceLabs would be the local machines ability to spawn a large amount of processes or threads
# RAM I think would be the ultimate issue.

# start up a queue that will spawn a process for the number of available VMs
# run the tests
#
# when a test is done, collect the results, update progress, store results (maybe to the database), grab new test off the top of the test pool

# TestObjects?

# {
#   run_id: "The id of the run that this test object was created for"  ---- I want to use this to later link to the test run for display in the web app
#   name: "Test name", #which will also be what is used to run the test
#   test_options: ['test options'],
#   run_time: some time in millisecond notation,
#   status: "Done", "Running", "In Queue",
#   results: "JSON string of results"
# }

=begin

  Start a test run
  TestRunObject?
  {
    run_id: "unique run id for the test run (include a time stamp for uniqueness?)",
    category: "Primary run, Rerun"
    project: "Apollo, RateView, Siebel, DAT Trucker, ALM"
    test_count: "Number of individual tests to be run",
    test_status: "Started", "Stopped", "Complete",
    pass_count: "the current number of tests that have passed",
    fail_count: "The current number of tests that have failed",
    test_failures: "an array of the rerun output generated by each test run",
    rerun: "boolean value stating whether or not this test run will rerun the failed tests",
    run_options: "an array of options that are used for this test" -- I currently have this property on the test object. May not need it in both places

  }

Test run queuing/scheduling?
TestQueueObject?

Emit == writing to the database

Start up a test run
  - TestRun.new(test_directory, options)
  - start status bar
  - parse the tests
  - update status bar
  - create all of the test objects and store them in an array
  - update status bar
  - get the limit for concurrent jobs from sauce labs
  - update status bar
  - emit test run creation event
  - spawn the test queue
    - start n threads (where n is the number of available concurrent jobs)
      - start start a test runner and pass in a test
      - emit new test creation event (maybe this event should be emitted when all of the tests objects are created and just emit an update to the tests status when it is started)
    - wait for threads to complete
    - when a thread is completed, assign the results to the test object
    - start a new thread sending the next test on the list
    - continue until there are no more tests in the list
    - where there are no more tests, wait for all threads to complete
    - when all threads have completed, emit a test run completion event
  - check to see if the test run is flagged for rerun
  - if it is check to see if there were any failures
  - if there are, start a new queue
  - once those are finished, emit a test run completion event
  - send all test objects to the test parser to have the results aggregated
  - record results to the database.


List of objects

TestRun
Test
EventEmitter
ProgressBar
DatabaseConnection
TestRunner
ResultsParser
Sauce


List of Emittable events



=end

