require_relative 'custom_accessor'
require_relative 'event_emitter'
require_relative 'event_handlers/event_handler_register'
require_relative 'test_run_result'

#--
# TestRunObject
# {
#     run_id: "unique run id for the test run (include a time stamp for uniqueness?)",
#     category: "Primary run, Rerun"
# project: "Apollo, RateView, Siebel, DAT Trucker, ALM"
# test_count: "Number of individual tests to be run",
#     status: "Started", "Stopped", "Complete",
#     pass_count: "the current number of tests that have passed",
#     fail_count: "The current number of tests that have failed",
#     test_failures: "an array of the rerun output generated by each test run",
#     rerun: "boolean value stating whether or not this test run will rerun the failed tests",
#     run_options: "an array of options that are used for this test" -- I currently have this property on the test object. May not need it in both places
#
# }
#++

module DATSauce
  class TestRun
    extend CustomAccessor
    include EventHandlerRegister

    custom_attr_accessor :runId, :projectName, :testCount, :rerun, :runOptions,
                         :tests, :queueSize, :results, :status, :startDate, :stopDate, :cmd


    # The TestRun object is responsible for storing and executing the meta data and events of a test run.
    # Is has the following properties available for use by EventHandlers
    # :run_id - a generated ID used for identifying the test run.
    # :project_name - the name of the project you are running this for. This is just a string, but was designed to be used for historical information when run information is stored in a database
    # :test_count - the number of tests to be executed for this run
    # :rerun - this is the value that determines if there is going to be a rerun and if that rerun is going to be parallel or serial
    # :run_options - these are the cucumber options that were passed to the test run and that will be used for each of the tests being executed as par of this run
    # :tests - this is an array of all the tests that will be executed in this test run
    # :queue_size - this is a slight misnomer. This is actually the max number of processes to be run at any given time.
    # :results - this an array of all of the results collected from the tests that have been run
    # :status - this is an indication as to where in the life cycle of a test run that the run is currently in
    # --
    # TODO: write a args parser for this instead of hard coding all of the attr_accessor values.
    # I really want to store these in a json config file.
    # ++
    # Constructor for the TestRun object
    # @param [Hash] hash a hash of options for the test run
    # {
    #     :project_name => String, #name of the project
    #     :run_options => Array, #an array of cucumber options
    #     :tests => Array, #an array of tests to be run
    #     :rerun => String, #serial or parallel (s/p) tells the application whether or not you want to do a rerun of the failures and if you want them to be run in serial or parallel
    #     :outputs => String, #tells the system how you want the progress and the results displayed to the user
    #     :run_location => Hash, #{:location, :desired_caps}
    #     :number_of_processes => Integer, #the number of concurrent processes you want running tests. Performance will decrease the higher you go. Typically, 2 times the number of physical cores is the ceiling
    # }

    def initialize(hash)
      @tests = hash[:tests]
      @testCount = @tests.length
      @runOptions = hash[:run_options]
      @rerun = hash[:rerun]
      @results = {:primary => nil, :rerun => nil}
      @runId = hash[:run_id] ? hash[:run_id] : generate_run_id(hash[:project_name])
      @event_emitter = EventEmitter.new
      @event_emitter.register_event_handlers(get_event_handlers(hash[:outputs]))
      @run_location = hash[:run_location]
      @status = 'Initialized'
      @number_of_processes = hash[:number_of_processes]
      @projectName = hash[:project_name]
      @cmd = hash[:cmd]
      @stopped = false
      trap_interrupt
    end


    # Start the test run
    #--
    # TODO - this feels like it should be implemented a little better. The summarizing of results should be placed elsewhere Im thinking
    # almost like the async style of node. Will look into it some other time
    #++
    def run

      @startDate = Time.now.to_i * 1000
      @status = 'Started'
      start_test_run(create_test_objects(@tests, @runOptions, @runId), @cmd)
      @status = 'Completed'
      @stopDate = Time.now.to_i * 1000
      @event_emitter.emit_event(test_run_completed: self)
      #add login for sending an exit code based on whether or not there were any failures.
    end

    # stop the test run
    # @note this has not been implemented yet and is on the TODO list.
    def stop
      unless @stopped
        @stopDate = Time.now.to_i * 1000
        @stopped = true
        @status = 'Stopped'
        @event_emitter.emit_event(info: "Received stop request at: #{Time.at(@stopDate)}")

        @threads.each do |t|
          t.kill
        end unless @threads.nil?

        @rerun_threads.each do |t|
          t.kill
        end unless @rerun_threads.nil?

        # sleep 10
        @threads.each do |t|
          t.join
        end unless @threads.nil?

        @rerun_threads.each do |t|
          t.join
        end unless @rerun_threads.nil?
        @event_emitter.emit_event(info: 'Test Run stopped, waiting for tests to finish')
        @event_emitter.emit_event(stop_test_run: self)
        exit 2
      end


      # need access to current threads
      # It would be nice to be able to send signals to sub processes to stop and record current results
      #TODO: implement this for a graceful shutdown of the test run.
      # TODO: need to emit a test_run_finished event
    end

    # converts all of the properties of the TestRun object into a Hash
    # @return [Hash]
    def to_hash
      obj = {}
      TestRun.attrs.each do |attr| #need to fix this. this looks at the Test class specifically and not whatever child class called it
        obj[attr] = send(attr)
      end
      obj
    end

    # converts all of the properties of the TestRun object into a json string
    def to_json
      # TODO: The tests array should be converted to an array of test ids rather than the actual test objects for insertion into the database
      # the tests will be written to the database independently and will be referenced instead of keeping 2 copies of the data in the database
      # JSON.generate to_hash
      hash  = to_hash
      results = {primary: nil, rerun: nil}
      results[:primary] = hash[:results][:primary].to_json unless hash[:results][:primary].nil?
      results[:rerun] = hash[:results][:rerun].to_json unless hash[:results][:rerun].nil?
      hash[:results] = results
      JSON.generate hash
    end

    # outputs all of the properties of the TestRun object as a String
    # @param [Boolean] log tells the method whether or not you want to output all of the results with the output
    def to_s(log = false)
      str = ''
      TestRun.attrs.each do |attr| #need to fix this. this looks at the Test class specifically and not whatever child class called it
        str << "#{attr}: #{send(attr)}\n" unless attr == :log && !log
      end
      str
    end


    private

    # Creates all of the test objects used to store all of the information for each test that is ran
    def create_test_objects(tests, run_options, run_id = @runId)
      @event_emitter.emit_event(:info => 'Creating test objects')
      test_objects = []
      tests.each do |test|
        test_object = DATSauce::Test.new(run_id, test, run_options)
        test_objects << test_object
        @event_emitter.emit_event(:test_created => test_object)
      end
      test_objects
    end

    #--
    # TODO - do a better implementation of getting the queue size
    # ++
    # sets the size for the number of tests to be run at any one time
    # @return [Int]
    def get_queue_size
      if @number_of_processes
        @queueSize = @number_of_processes
      else
        @queueSize = DATSauce::PlatformUtils.processor_count * 2
        # get max threads from platform utils
      end
      @queueSize
    end

    # starts the test run
    def start_test_run(test_objects, cmd=nil)
      @status = 'Running'
      @event_emitter.emit_event :start_test_run => self
      @event_emitter.emit_event :info => 'Starting test run'
      start_time = Time.now
      @threads = []
      get_queue_size.times do
        test = get_next_test(test_objects)
        @threads << run_test(test, cmd) unless test.nil?
        sleep 0.5 #this is an attempt at a stop gap for the account rental service not being able to handle multiple requests at once (accounts are being rented out when they should not be)
      end
      start_queue(test_objects, @threads, cmd) unless @stopped
      process_run_results(test_objects, :primary, start_time, @runId) unless @stopped
      if !@rerun.nil? && !@rerun.empty? || !@stopped
        @event_emitter.emit_event :info => 'This test run has been flagged for rerun. Starting rerun...'
        if there_are_failures?(test_objects) && !@stopped
          _start_time = Time.now
          start_rerun(test_objects, @rerun, cmd) unless @stopped
          process_run_results(test_objects, :rerun, _start_time, @runId) unless @stopped
        else
          @event_emitter.emit_event :info => 'There were no failures detected. A rerun was not necessary.'
        end unless @stopped
      end

      @results[:runTime] = Time.now - start_time
      # @event_emitter.emit_event :test_run_completed => self
    end

    def there_are_failures?(test_objects)
      test_objects.each do |test|
        return true if test.status == 'failed' && test.runCount <= 1
      end
      false
    end

    def start_rerun(test_objects, rerun_type, cmd)
      if !@stopped
        @rerun_threads = []
        rerun_count = get_rerun_count(test_objects)

        @event_emitter.emit_event(:start_rerun => rerun_count)

        queue = 0
        # this could be written differently to save a couple of lines of code
        if rerun_type == 'serial'
          queue = 1
        elsif rerun_type == 'parallel'
          queue = @queueSize
        else
          @event_emitter.emit_event :info => 'Did not recognize rerun type or none was passed. Running the rerun in parallel mode'
          queue = @queueSize
        end
        queue.times do
          test = get_next_rerun_test(test_objects)
          break if test.nil? || @stopped
          @rerun_threads << run_test(test, cmd) unless @stopped
        end unless @stopped
        if get_next_rerun_test(test_objects).nil? && !@stopped
          @event_emitter.emit_event :info => 'There are no more tests in the queue. Waiting for current tests to finish...'
          @rerun_threads.each {|t| t.join}
        else
          start_rerun_queue(test_objects, @rerun_threads, queue, cmd) unless @stopped
        end unless @stopped
      end

    end

    #TODO: I might want to move all of this thread work to some kind of thread handler
    #TODO: I can probably improve the performance here by doing some kind of caching. Will revisit later
    def start_queue(test_objects, threads, cmd)
      @event_emitter.emit_event :info => 'All test processes full. Sending remaining tests to the test queue...'
      test = get_next_test(test_objects)
      while test != nil
        break if @stopped
        if get_active_thread_count(threads) < @queueSize
          threads << run_test(test, cmd)
          test = get_next_test(test_objects)
        end unless @stopped
      end
      if @stopped
        @event_emitter.emit_event :info => 'Test run was stopped. Aborting queue and waiting for tests to complete....'
      else
        @event_emitter.emit_event :info => 'Queue complete. Waiting for tests to finish running...'
      end

      threads.each do |t|
        t.join
      end
      # done = false
      # until done do
      #   stat = []
      #   threads.each do |t|
      #     stat << t.status
      #   end
      #   done = true unless stat.include?('sleep') || stat.include?('run') || stat.include?('aborting')
      #   sleep 1
      # end
    end

    def start_rerun_queue(test_objects, threads, queue, cmd)
      @event_emitter.emit_event :info => 'All test processes full. Sending remaining tests to the test queue...'
      test = get_next_rerun_test(test_objects)
      while test != nil
        break if @stopped
        if get_active_thread_count(threads) < queue
          threads << run_test(test, cmd)
          test = get_next_rerun_test(test_objects)
        end unless @stopped
      end unless @stopped

      @event_emitter.emit_event :info => 'Queue completed. Waiting for current tests to finish...'
      threads.each {|t| t.join}
    end

    def get_next_test(test_objects)
      test_objects.each do |test|
        if test.status == 'In Queue'
          test.status = 'Processing'
          return test
        end
      end
      nil
    end

    #TODO: need to revisit this, make sure its working the way I think it does
    def get_rerun_count(test_objects)
      count = 0
      test_objects.each do |test|
        if test.status == 'failed'
          count +=1
        end
      end
      count
    end


    def get_next_rerun_test(test_objects)
      test_objects.each do |test|
        if test.status == 'failed' && test.runCount <= 1
          test.status = 'Processing'
          return test
        end
      end
      nil
    end

    def get_active_thread_count(threads)
      threads.delete_if { |thread| !thread.alive?}
      threads.length
    end

    def run_test(test, cmd)
      Thread.new(test, cmd) {|t, _cmd|
        @event_emitter.emit_event :start_test => t
        t.run(_cmd)
        if t.status == 'Stopped'
          @event_emitter.emit_event :stop_test => t
        else
          @event_emitter.emit_event :test_completed => t
        end

      } # event_emitter.test_completed(t) /after the test is completed emit the test completion event and send the test object to the emitter
      # this keeps the emitter out of the test object while only sending it one thread deep. Hopefully I dont run into resource conflicts here.
      # also, perhaps it would be best to do results parsing here rather than at the end of the run
    end

    #TODO - add some progress bar modifications here while the results are being processed. This appears to take a while.
    # TODO: this should not be here. This should be part of a event handler
    def process_run_results(test_objects, run_type, start_time, run_id)
      @event_emitter.emit_event :info => 'Processing results. This may take a minute...'

      primary = []
      rerun = []
      @event_emitter.emit_event :update_stats => '' #this needs to be an object not a string. will implement later
      test_objects.each do |test|

        if run_type == :primary
          primary << test.results[:primary] unless test.results.nil?
          primary.flatten!
        elsif run_type == :rerun
          unless test.results[:rerun].nil?
            rerun << test.results[:rerun]
            rerun.flatten!
          end
        end

      end
      if run_type == :primary
        @results[:primary] = DATSauce::TestRunResult.new primary, start_time, run_id, 'primary'
      elsif run_type == :rerun
        @results[:rerun] = DATSauce::TestRunResult.new rerun, start_time, run_id, 'rerun'
      end
    end

    def generate_run_id(project_name)
      project_name + "#{Time.now.to_i.to_s}"
    end

    def trap_interrupt
      p = Signal.trap('INT') do
        stop
        # p = ->{raise SignalException, 'INT'} unless p.respond_to? :call
        # p.call
      end
    end

  end


end