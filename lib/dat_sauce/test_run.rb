require_relative 'base_test'

# TestRunObject?
# {
#     run_id: "unique run id for the test run (include a time stamp for uniqueness?)",
#     category: "Primary run, Rerun"
# project: "Apollo, RateView, Siebel, DAT Trucker, ALM"
# test_count: "Number of individual tests to be run",
#     test_run_status: "Started", "Stopped", "Complete",
#     pass_count: "the current number of tests that have passed",
#     fail_count: "The current number of tests that have failed",
#     test_failures: "an array of the rerun output generated by each test run",
#     rerun: "boolean value stating whether or not this test run will rerun the failed tests",
#     run_options: "an array of options that are used for this test" -- I currently have this property on the test object. May not need it in both places
#
# }

module DATSauce
  class TestRun < BaseTest

    custom_attr_accessor :run_id, :project, :test_count, :test_run_status, :rerun, :run_options,
                         :tests, :runner_type, :desired_caps, :queue_size, :results


    # TODO: write a args parser for this instead of hard coding all of the attr_accessor values
    def initialize(project, run_options, rerun, tests, event_emitter, runner_type, desired_caps)
      @project = project
      @tests = tests
      @test_count = @tests.length
      @run_options = run_options
      @rerun = rerun
      @results = {:primary => nil, :rerun => nil}
      @run_id = generate_run_id
      @event_emitter = event_emitter
      @runner_type = runner_type
      @desired_caps = desired_caps
      @progress_bar = DATSauce::ProgressBar.new()
    end


    def create_test_objects(tests, run_options, run_id = @run_id)
      test_objects = []
      tests.each do |test|
        test_objects << DATSauce::Test.new(run_id, test, run_options)
      end
      test_objects
    end

    def get_queue_size
      if @runner_type == 'sauce'
        # get max concurrent tests from sauce and assign to @queue_size
        @queue_size = 8 #this is hard coded for now. Will change later
      elsif @runner_type == 'grid'
        # get max nodes from grid
      elsif @runner_type == 'local'
        # get max threads from platform utils
      end
    end

    def start_test_run(test_objects)
      start_time = Time.now
      threads = []
      get_queue_size.times do
        test = get_next_test(test_objects)
        threads << run_test(test)
      end
      start_queue(test_objects, threads)

      if @rerun
        start_rerun(test_objects)
      end

      process_run_results(test_objects, start_time)

    end

    def start_rerun(test_objects)
      threads = []
      @queue_size.times do
        test = get_next_rerun_test(test_objects)
        threads << run_test(test)
      end
      start_rerun_queue(test_objects, threads)
    end


    #TODO: I can probably improve the performance here by doing some kind of caching. Will revisit later
    def start_queue(test_objects, threads)
      test = get_next_test(test_objects)
      while test != nil
        if get_active_thread_count(threads) < @queue_size
          threads << run_test(test)
          test = get_next_test(test_objects)
        end
      end
      threads.join
    end

    def start_rerun_queue(test_objects, threads)
      test = get_next_rerun_test(test_objects)
      while test != nil
        if get_active_thread_count(threads) < @queue_size
          threads << run_test(test)
          test = get_next_rerun_test(test_objects)
        end
      end
      threads.join
    end

    def get_next_test(test_objects)
      test_objects.each do |test|
        return test if test.status "In Queue"
      end
      nil
    end

    def get_next_rerun_test(test_objects)
      test_objects.each do |test|
        return test if !test.results[:primary][:failed_tests].nil?
      end
      nil
    end

    def get_active_thread_count(threads)
      threads.delete_if { |thread| !thread.alive?}
      threads.length
    end

    def run_test(test)
      Thread.new(test) {|t| t.run}
    end

    def process_run_results(test_objects, start_time)
      primary_results_log = ''
      primary_run_time = 0
      primary_failures = []
      rerun_results_log = ''
      rerun_failures = []
      rerun_run_time = 0
      test_objects.each do |test|
        primary_results_log << test.results[:primary][:results]
        primary_run_time += test.results[:primary][:run_time]
        primary_failures << test.results[:primary][:failed_tests]
        rerun_results_log << test.results[:rerun][:results]
        rerun_run_time += test.results[:rerun][:run_time]
        rerun_failures << test.results[:rerun][:failed_tests]
      end


      @results[:primary] = {
          :results =>primary_results_log,
          :results_summary => DATSauce::Cucumber::ResultsParser.summarize_results(primary_results_log),
          :pass_count => DATSauce::Cucumber::ResultsParser.scenario_counts[:pass],
          :fail_count => DATSauce::Cucumber::ResultsParser.scenario_counts[:fail],
          :failed_tests =>primary_failures,
          :run_time => primary_run_time
      }

      @results[:rerun] = {
          :results =>rerun_results_log,
          :results_summary => DATSauce::Cucumber::ResultsParser.summarize_results(rerun_results_log),
          :pass_count => DATSauce::Cucumber::ResultsParser.scenario_counts[:pass],
          :fail_count => DATSauce::Cucumber::ResultsParser.scenario_counts[:fail],
          :failed_tests =>rerun_failures,
          :run_time => rerun_run_time
      }
      @results[:run_time] = (start_time - Time.now).to_i * 1000

    end




    def update_stats
      #TODO: Need to rethink this. Its just going to update the count over and over again.
      #Proccess.spawn {
      # @test_objects.each do |test|
      #   if test.status == "Done"
      #     @pass_count += test.pass_count
      #     @fail_count += test.fail_count
      # }
    end

    private

    def generate_run_id
      @project + "#{Time.now.to_i.to_s}"
    end


  end


end